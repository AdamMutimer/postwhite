#! /bin/bash
#
# Postwhite - Automatic Postcreen Whitelist Generator
#
# By Steve Jenkins (http://stevejenkins.com/)
	version="1.33"
	lastupdated="13 June 2016"
#
# Usage: place entire postwhite directory in /usr/local/bin then 
# run ./postwhite
#
# Requires SPF-Tools (https://github.com/jsarenik/spf-tools)
# Please update your copy of spf-tools whenever you update Postwhite

# Thanks to Mike Miller (mmiller@mgm51.com) for gwhitelist.sh script
# Thanks to Jan Sarenik for SPF-Tools
# Thanks to Jose Borges Ferreira for IPv4 normalization help

# USER-DEFINABLE OPTIONS

# spf-tools location (REQUIRED)
spftoolspath=/usr/local/bin/spf-tools

# Do this to invalid IPv4 addresses and CIDRs (remove / fix / keep)
invalidip4=remove

# Simplify (remove) IP addresses from the whitelist that are already covered by CIDRs
# WARNING: Enabling this option can dramatically increase the time Postwhite takes to
# run if you have many mailers selected. Try it once, then come back and turn it off. :)
simplify=no

# Paths
postfixpath=/etc/postfix
postfixbinarypath=/usr/sbin
whitelist=postscreen_spf_whitelist.cidr

# Reload Postfix Automatically when done?
reloadpostfix=yes

# Groups of hosts to be queried (edit to your liking)
webmail_hosts="aol.com google.com microsoft.com outlook.com hotmail.com gmx.com icloud.com mail.com inbox.com zoho.com fastmail.com"

social_hosts="facebook.com twitter.com pinterest.com instagram.com tumblr.com reddit.com linkedin.com"

commerce_hosts="craigslist.org amazon.com ebay.com paypal.com"

bulk_hosts="sendgrid.com sendgrid.net mailchimp.com exacttarget.com cust-spf.exacttarget.com constantcontact.com icontact.com mailgun.com fishbowl.com fbmta.com mailjet.com"

misc_hosts="zendesk.com github.com"

# NO NEED TO EDIT PAST THIS LINE

# abort on any error
set -e

# Create temporary files
tmpBase=$(basename "$0")
tmp1=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
tmp2=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
tmp3=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
tmp4=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
tmp5=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
	if [ $? -ne 0 ]; then
		printf "$0: Can't create temp files, exiting...\n"
		exit 1
	fi

# Create IPv4 normalize function
ip2int() {
    local a b c d
    { IFS=. read a b c d; } <<< $1
    printf $(((((((a << 8) | b) << 8) | c) << 8) | d))
}

int2ip() {
    local ui32=$1; shift
    local ip n
    for n in 1 2 3 4; do
        ip=$((ui32 & 0xff))${ip:+.}$ip
        ui32=$((ui32 >> 8))
    done
    printf $ip
}

network() {
    local ia netmask;
    { IFS="/" read ia netmask; } <<< $1
    local addr=$(ip2int $ia);
    local mask=$((0xffffffff << (32 -$netmask)));
    printf $(int2ip $((addr & mask)))/$netmask
}

function normalize_ipv4() {
	# split by ":"
	local array=(${ip/:/ });
	if [ "x${array[0]}" = "xip4" ] ; then
		# check if is a CIDR
		if [[ ${array[1]} == *"/"32 ]] ; then
			IP=${array[1]}
		elif [[ ${array[1]} == *"/"* ]] ; then
			IP=$(network ${array[1]});
		else
			IP=${array[1]}
		fi
	else
		IP=${array[1]}
	fi
	printf "$IP"
}

# Create host query function
function query_host() {
	"${spftoolspath}"/despf.sh "$1" >> "${tmp1}"
}

# Create progress dots function
function show_dots() {
	while ps $1 >/dev/null ; do
	printf "."
	sleep 1
	done
	printf "\n"
}

# Let's DO this!

printf "\nStarting Postwhite v$version ($lastupdated)\n"

printf "\nRecursively querying SPF records of selected mailers...\n"

# Query selected mailers

printf "\nQuerying webmail hosts...\n"

for h in ${webmail_hosts}; do
    $(query_host "${h}")
done

printf "\nQuerying social network hosts...\n"

for h in ${social_hosts}; do
    $(query_host "${h}")
done

printf "\nQuerying ecommerce hosts...\n"

for h in ${commerce_hosts}; do
    $(query_host "${h}")
done

printf "\nQuerying bulk mail hosts...\n"

for h in ${bulk_hosts}; do
    $(query_host "${h}")
done

printf "\nQuerying other hosts...\n"

for h in ${misc_hosts}; do
    $(query_host "${h}")
done

# If enabled, simplify (remove) any individual IPs already included in CIDR ranges (disabled by default)
if [ "$simplify" == "yes" ]; then
	printf "\nSimplifying IP addresses already included in CIDR ranges. These calculations\n"
	printf "can take a LONG time if you have many mailers selected. Please be patient..."
	cat "${tmp1}" | "${spftoolspath}"/simplify.sh > "${tmp2}" &
	show_dots $!
	printf "\nIP address simplification complete.\n"
else
	cat "${tmp1}" > "${tmp2}"
fi

# Check for invalid IPv4 CIDRs, then format the whitelist

# If enabled, fix invalid CIDRs
if [ "$invalidip4" == "fix" ] ; then
	printf "\nFixing invalid IPv4 CIDRs..."
	for ip in $(cat  "${tmp2}") ; do
		ip=$(normalize_ipv4  "$ip");
		if [ -n "$ip" ] ; then
			printf "$ip\tpermit\n"
		fi
	done >> "${tmp3}" &
	show_dots $!

# If enabled, remove invalid CIDRs
elif [ "$invalidip4" == "remove" ] ; then
	printf "\nRemoving invalid IPv4 CIDRs..."
	for ip in $(cat "${tmp2}") ; do
		iptype=$( printf "$ip" | cut -d\: -f1 )
		origip=$( printf "$ip" | cut -d\: -f2 )
		ip=$(normalize_ipv4 "$ip");
		if [ "$origip" == "$ip" ] ; then
			printf "$ip\tpermit\n"
		elif [ "$iptype" == "ip6" ] ; then
			printf "$ip\tpermit\n"
		fi
	done >> "${tmp3}" &
	show_dots $!

# If enabled, keep invalid CIDRs
elif [ "$invalidip4" == "keep" ] ; then
	printf "\nKeeping invalid IPv4 CIDRs...\n"
	printf "%s\n" | grep "^ip" "${tmp2}" | cut -c5- | sed s/$/'	permit'/ > "${tmp3}"
fi

# Sort, uniq, and count final rules
# Have to do sort and uniq separately, as 'sort -u -t. -k1,1n...' removes valid rules
printf "\nSorting whitelist rules...\n"
sort -t. -k1,1n -k2,2n -k3,3n -k4,4n "${tmp3}" > "${tmp4}"
uniq "${tmp4}" >> "${tmp5}"
numrules="$(cat "${tmp5}" | wc -l)"

# Write whitelist to Postfix directory
printf "\nWriting $numrules whitelist rules to ${postfixpath}/${whitelist}...\n"
printf "# Generated by Postwhite v$version on $(date)\n# https://github.com/stevejenkins/postwhite/\n# $numrules total rules\n" > "${postfixpath}"/"${whitelist}"
cat "${tmp5}" >> "${postfixpath}"/"${whitelist}"

# Remove temp files
test -e "${tmp1}" && rm "${tmp1}"
test -e "${tmp2}" && rm "${tmp2}"
test -e "${tmp3}" && rm "${tmp3}"
test -e "${tmp4}" && rm "${tmp4}"
test -e "${tmp5}" && rm "${tmp5}"

# Reload Postfix to pick up changes in whitelist
if [ "$reloadpostfix" == "yes" ]; then
printf '\nReloading Postfix configuration to refresh whitelist rules...\n'
	${postfixbinarypath}/postfix reload
fi

printf '\nDone!\n'

exit
