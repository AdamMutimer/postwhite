#!/bin/sh

###################################################################
# Postwhite - Automatic Postcreen Whitelist / Blacklist Generator #
# https://github.com/stevejenkins/postwhite                       #
###################################################################

# By Steve Jenkins (https://www.stevejenkins.com/)

version="2.3"
lastupdated="4 March 2017"

# Usage: 1) Place entire /postwhite directory in /usr/local/bin
#	 2) Move postwhite.conf to /etc
#	 3) Run ./postwhite

# Requires SPF-Tools (https://github.com/jsarenik/spf-tools)
# Please update your copy of spf-tools whenever you update Postwhite

# Thanks to Mike Miller (mmiller@mgm51.com) for gwhitelist.sh script
# Thanks to Jan Sarenik for SPF-Tools
# Thanks to Jose Borges Ferreira for IPv4 normalization help

# USER-DEFINABLE OPTIONS AND CUSTOM HOSTS STORED IN /etc/postwhite.conf

# NO NEED TO EDIT PAST THIS LINE

#################################################################

# DEFAULT HOSTS
# CUSTOM HOSTS CAN BE ADDED IN /etc/postwhite.conf

# Hosts to query
webmail_hosts="aol.com google.com microsoft.com outlook.com hotmail.com gmx.com icloud.com mail.com inbox.com zoho.com fastmail.com"

social_hosts="facebook.com facebookmail.com twitter.com pinterest.com instagram.com tumblr.com reddit.com linkedin.com"

commerce_hosts="craigslist.org amazon.com ebay.com paypal.com"

bulk_hosts="sendgrid.com sendgrid.net mailchimp.com exacttarget.com cust-spf.exacttarget.com constantcontact.com icontact.com mailgun.com fishbowl.com fbmta.com mailjet.com sparkpost.com sparkpostmail.com"

misc_hosts="zendesk.com github.com"

permit_line_v4="%s\tpermit\n"
reject_line_v4="%s\treject\n"

permit_line_v6="${permit_line_v4}"
reject_line_v6="${reject_line_v4}"

# Abort script on error (fyi: enabling will cause script to exit silently if mailer has no valid results)
set -e

printf "Starting Postwhite v$version ($lastupdated)\n"

if [ -n $2 ]; then
	config_file="/etc/postwhite.conf"
else
	config_file="$2"
fi

# Read config file options
if [ -s $config_file ] ; then
	printf "\nReading options from %s...\n" "$config_file"
	. "${config_file}"
else
	printf "\nCan't find %s. Exiting.\n\n" "$config_file"
	exit 1
fi

# Create temporary files
printf "\nCreating temporary files...\n"
tmpBase=$(basename "$0")
tmp1=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
tmp2=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
tmp3=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
tmp4=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
tmp5=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
if [ "$enable_blacklist" = "yes" ] ; then
	blktmp1=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
	blktmp2=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
	blktmp3=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
	blktmp4=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
	blktmp5=$(mktemp -q /tmp/"${tmpBase}".XXXXXX)
fi
	if [ $? -ne 0 ]; then
		printf "$0: Can't create temp files, exiting...\n"
		exit 1
	fi

# Create IPv4 normalize function
ip2int() {
    ip2int_a=$(echo "$1" | cut -s -d. -f1)
    ip2int_b=$(echo "$1" | cut -s -d. -f2)
    ip2int_c=$(echo "$1" | cut -s -d. -f3)
    ip2int_d=$(echo "$1" | cut -s -d. -f4)
    printf $(((((((ip2int_a << 8) | ip2int_b) << 8) | ip2int_c) << 8) | ip2int_d))
}

int2ip() {
    int2ip_ui32=$1; shift
    for n in 1 2 3 4; do
        int2ip_ip=$((int2ip_ui32 & 0xff))${int2ip_ip:+.}$int2ip_ip
        int2ip_ui32=$((int2ip_ui32 >> 8))
    done
    printf "%s" "${int2ip_ip}"
}

network() {
    network_ia=$(echo "$1" | cut -d/ -f1)
    network_netmask=$(echo "$1" | cut -d/ -f2)
    network_addr=$(ip2int $network_ia);
    network_mask=$((0xffffffff << (32 -$network_netmask)));
    if [ $network_netmask -eq 32 ]; then
        printf "%s" $(int2ip $((network_addr & network_mask)))
    else
        printf "%s/%s" $(int2ip $((network_addr & network_mask))) $network_netmask
    fi
}

normalize_ipv4() {
	# split by ":"
	normalize_ipv4_ip_type=$( echo ${ip} | cut -s -d\: -f1)
	normalize_ipv4_ip_value=$( echo ${ip} | cut -s -d\: -f2)
	if [ "x${normalize_ipv4_ip_type}" = "xip4" ] ; then
		# check if is a CIDR
		if expr "x${normalize_ipv4_ip_value}" : "x.*/[0-9]*"; then
			IP=$(network "${normalize_ipv4_ip_value}");
		else
			IP=$(network "${normalize_ipv4_ip_value}/32");
		fi
	else
		IP=${normalize_ipv4_ip_value}
	fi
	printf "%s" "$IP"
}

# Create host query function
query_host() {
	"${spftoolspath}"/despf.sh "$1" | (grep -Ei ^ip || true ) >> "${tmp1}"
}

query_black_host() {
	"${spftoolspath}"/despf.sh "$1" | (grep -Ei ^ip || true ) >> "${blktmp1}"
}

# Create progress dots function
show_dots() {
	while ps $1 >/dev/null ; do
	printf "."
	sleep 1
	done
	printf "\n"
}

# Let's DO this!

printf "\nRecursively querying SPF records of selected whitelist mailers...\n"

# Query selected mailers

printf "\nQuerying webmail hosts...\n"

for h in ${webmail_hosts}; do
    $(query_host "${h}")
done

printf "\nQuerying social network hosts...\n"

for h in ${social_hosts}; do
    $(query_host "${h}")
done

printf "\nQuerying ecommerce hosts...\n"

for h in ${commerce_hosts}; do
    $(query_host "${h}")
done

printf "\nQuerying bulk mail hosts...\n"

for h in ${bulk_hosts}; do
    $(query_host "${h}")
done

printf "\nQuerying miscellaneous hosts...\n"

for h in ${misc_hosts}; do
    $(query_host "${h}")
done

printf "\nQuerying custom hosts...\n"
          
for h in ${custom_hosts}; do
    $(query_host "${h}")
done

if [ "$include_yahoo" = "yes" ] ; then
	printf "\nIncluding static Yahoo hosts...\n"

	cat "${yahoo_static_hosts}" >> "${tmp1}"
fi

if [ "$enable_blacklist" = "yes" ] ; then
	printf "\nQuerying blacklist hosts...\n"

	for h in ${blacklist_hosts}; do
	    $(query_black_host "${h}")
	done
fi

# If enabled, simplify (remove) any individual IPs already included in CIDR ranges (disabled by default)
if [ "$simplify" = "yes" ]; then
	printf "\nSimplifying whitelist IP addresses already included in CIDR ranges. These calculations\n"
	printf "can take a LONG time if you have many mailers selected. Please be patient..."
	
	cat "${tmp1}" | sort -u | "${spftoolspath}"/simplify.sh > "${tmp2}" &
	show_dots $!

	if [ "$enable_blacklist" = "yes" ] ; then
		printf "\nSimplifying blacklist IP addresses already included in CIDR ranges. These calculations\n"
	        printf "can take a LONG time if you have many mailers selected. Please be patient..."
	        cat "${blktmp1}" | sort -u | "${spftoolspath}"/simplify.sh > "${blktmp2}" &
	        show_dots $!
	fi
	
	printf "\nIP address simplification complete.\n"
else
	cat "${tmp1}" > "${tmp2}"
	if [ "$enable_blacklist" = "yes" ] ; then
		cat "${blktmp1}" > "${blktmp2}"
	fi
fi

# Check for invalid IPv4 CIDRs, then format the whitelist

# If enabled, fix invalid CIDRs
if [ "$invalid_ip4" = "fix" ] ; then
	printf "\nFixing invalid whitelist IPv4 CIDRs..."
	for ip in $(cat  "${tmp2}") ; do
		ip=$(normalize_ipv4  "$ip");
		if [ -n "$ip" ] ; then
			printf "${permit_line_v4}" "$ip"
		fi
	done >> "${tmp3}" &
	show_dots $!

	if [ "$enable_blacklist" = "yes" ] ; then
		printf "\nFixing invalid blacklist IPv4 CIDRs..."
 		for ip in $(cat  "${blktmp2}") ; do
	                ip=$(normalize_ipv4  "$ip");
	                if [ -n "$ip" ] ; then
				printf "${reject_line_v4}" "$ip"
	                fi
        done >> "${blktmp3}" &
        show_dots $!
	fi

# If enabled, remove invalid CIDRs
elif [ "$invalid_ip4" = "remove" ] ; then
	printf "\nRemoving invalid IPv4 CIDRs from whitelist..."
	for ip in $(cat "${tmp2}") ; do
		iptype=$( echo "$ip" | cut -d\: -f1 )
		origip=$( echo "$ip" | cut -d\: -f2 )
		ip=$(normalize_ipv4 "$ip");
		if [ "$origip" = "$ip" ] ; then
			printf "${permit_line_v4}" "$ip"
		elif [ "$iptype" = "ip6" ] ; then
			printf "${permit_line_v6}" "$ip"
		fi
	done >> "${tmp3}" &
	show_dots $!

	if [ "$enable_blacklist" = "yes" ] ; then
		printf "\nRemoving invalid IPv4 CIDRs from blacklist..."
		for ip in $(cat "${blktmp2}") ; do
			iptype=$( echo "$ip" | cut -d\: -f1 )
			origip=$( echo "$ip" | cut -d\: -f2 )
			ip=$(normalize_ipv4 "$ip");
			if [ "$origip" = "$ip" ] ; then
				printf "${reject_line_v4}" "$ip"
			elif [ "$iptype" = "ip6" ] ; then
				printf "${reject_line_v6}" "$ip"
			fi
		done >> "${blktmp3}" &
		show_dots $!
	fi

# If enabled, keep invalid CIDRs
elif [ "$invalid_ip4" = "keep" ] ; then
	printf "\nKeeping invalid whitelist IPv4 CIDRs...\n"
	printf "%s\n" | grep "^ip" "${tmp2}" | cut -c5- | sed s/$/'	permit'/ > "${tmp3}"
	if [ "$enable_blacklist" = "yes" ] ; then
		printf "\nKeeping invalid blacklist IPv4 CIDRs...\n"
		printf "%s\n" | grep "^ip" "${blktmp2}" | cut -c5- | sed s/$/'	reject'/ > "${blktmp3}"
		fi
fi

# Sort, uniq, and count final rules
# Have to do sort and uniq separately, as 'sort -u -t. -k1,1n...' removes valid rules
printf "\nSorting whitelist rules...\n"
sort -t. -k1,1n -k2,2n -k3,3n -k4,4n "${tmp3}" > "${tmp4}"
uniq "${tmp4}" >> "${tmp5}"
numrules="$(cat "${tmp5}" | wc -l)"

if [ "$enable_blacklist" = "yes" ] ; then
	printf "\nSorting blacklist rules...\n"
	sort -t. -k1,1n -k2,2n -k3,3n -k4,4n "${blktmp3}" > "${blktmp4}"
	uniq "${blktmp4}" >> "${blktmp5}"
	numblackrules="$(cat "${blktmp5}" | wc -l)"
fi

# Write whitelist and blacklist to Postfix directory
printf "\nWriting $numrules whitelist rules to ${postfixpath}/${whitelist}...\n"
printf "# Whitelist generated by Postwhite v$version on $(date)\n# https://github.com/stevejenkins/postwhite/\n# $numrules total rules\n" > "${postfixpath}"/"${whitelist}"
cat "${tmp5}" >> "${postfixpath}"/"${whitelist}"

if [ "$enable_blacklist" = "yes" ] ; then
	printf "\nWriting $numblackrules blacklist rules to ${postfixpath}/${blacklist}...\n"
	printf "# Blacklist generated by Postwhite v$version on $(date)\n# https://github.com/stevejenkins/postwhite/\n# $numblackrules total rules\n" > "${postfixpath}"/"${blacklist}"
	cat "${blktmp5}" >> "${postfixpath}"/"${blacklist}"
fi

# Remove temp files
test -e "${tmp1}" && rm "${tmp1}"
test -e "${tmp2}" && rm "${tmp2}"
test -e "${tmp3}" && rm "${tmp3}"
test -e "${tmp4}" && rm "${tmp4}"
test -e "${tmp5}" && rm "${tmp5}"
if [ "$enable_blacklist" = "yes" ] ; then
	test -e "${blktmp1}" && rm "${blktmp1}"
	test -e "${blktmp2}" && rm "${blktmp2}"
	test -e "${blktmp3}" && rm "${blktmp3}"
	test -e "${blktmp4}" && rm "${blktmp4}"
	test -e "${blktmp5}" && rm "${blktmp5}"
fi

# Reload Postfix to pick up changes in whitelist
if [ "$reload_postfix" = "yes" ]; then
printf '\nReloading Postfix configuration to refresh rules...\n'
	${postfixbinarypath}/postfix reload
fi

printf '\nDone!\n'

exit
